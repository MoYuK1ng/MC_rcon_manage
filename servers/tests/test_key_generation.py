"""
Property-based and unit tests for key generation (generate_key.py)
"""

import os
import tempfile
import shutil
import pytest
from hypothesis import given, strategies as st
from cryptography.fernet import Fernet

from servers.utils.key_validator import KeyValidator
from servers.utils.encryption import EncryptionUtility


# Feature: rcon-encryption-refactor, Property 4: Generated keys are valid
@given(st.integers(min_value=1, max_value=100))
def test_generated_keys_are_valid(iteration):
    """
    Property 4: Generated keys are valid
    For any key generated by Fernet.generate_key(), the key should pass validation as a valid Fernet key.
    """
    # Generate a key (simulating what generate_key.py does)
    key = Fernet.generate_key()
    key_string = key.decode('utf-8')
    
    # Validate the key
    is_valid, error_message = KeyValidator.validate_key(key_string)
    
    assert is_valid, f"Generated key failed validation: {error_message}"
    assert error_message == ""


# Feature: rcon-encryption-refactor, Property 5: Backup creation with timestamp
def test_backup_creation_with_timestamp():
    """
    Property 5: Backup creation with timestamp
    For any existing .env file, when updating it, a backup file should be created with a timestamp in the filename.
    """
    # Create a temporary directory
    with tempfile.TemporaryDirectory() as tmpdir:
        env_file = os.path.join(tmpdir, '.env')
        
        # Create an existing .env file
        with open(env_file, 'w') as f:
            f.write('EXISTING_KEY=old_value\n')
        
        # Simulate backup creation (what generate_key.py does)
        from datetime import datetime
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = os.path.join(tmpdir, f'.env.backup_{timestamp}')
        shutil.copy2(env_file, backup_file)
        
        # Verify backup exists
        assert os.path.exists(backup_file), "Backup file should exist"
        
        # Verify backup has timestamp in filename
        assert 'backup_' in os.path.basename(backup_file), "Backup filename should contain 'backup_'"
        assert timestamp in os.path.basename(backup_file), "Backup filename should contain timestamp"
        
        # Verify backup content matches original
        with open(env_file, 'r') as f:
            original_content = f.read()
        with open(backup_file, 'r') as f:
            backup_content = f.read()
        
        assert original_content == backup_content, "Backup content should match original"


# Feature: rcon-encryption-refactor, Property 6: Generated keys work with EncryptionUtility
@given(st.integers(min_value=1, max_value=50))
def test_generated_keys_work_with_encryption_utility(iteration):
    """
    Property 6: Generated keys work with EncryptionUtility
    For any key generated by Fernet.generate_key(), the EncryptionUtility should be able to use it for encryption operations.
    """
    # Generate a key
    key = Fernet.generate_key()
    
    # Try to create EncryptionUtility with this key
    util = EncryptionUtility(key=key)
    
    # Test encryption/decryption
    test_password = "test_password_123"
    encrypted = util.encrypt(test_password)
    decrypted = util.decrypt(encrypted)
    
    assert decrypted == test_password, "Generated key should work for encryption/decryption"
    assert util.verify_encryption(test_password), "verify_encryption should return True"


# Feature: rcon-encryption-refactor, Property 7: Backup restoration on failure
def test_backup_restoration_on_failure():
    """
    Property 7: Backup restoration on failure
    For any .env file, if key generation fails after creating a backup, the original .env file should be restored from the backup.
    """
    with tempfile.TemporaryDirectory() as tmpdir:
        env_file = os.path.join(tmpdir, '.env')
        
        # Create original .env file
        original_content = 'ORIGINAL_KEY=original_value\nOTHER_SETTING=value\n'
        with open(env_file, 'w') as f:
            f.write(original_content)
        
        # Create backup
        from datetime import datetime
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = os.path.join(tmpdir, f'.env.backup_{timestamp}')
        shutil.copy2(env_file, backup_file)
        
        # Simulate a failure by modifying the .env file
        with open(env_file, 'w') as f:
            f.write('CORRUPTED_DATA\n')
        
        # Verify file was modified
        with open(env_file, 'r') as f:
            assert f.read() == 'CORRUPTED_DATA\n'
        
        # Restore from backup (simulating rollback)
        shutil.copy2(backup_file, env_file)
        
        # Verify restoration
        with open(env_file, 'r') as f:
            restored_content = f.read()
        
        assert restored_content == original_content, "File should be restored to original content"


class TestKeyGenerationScript:
    """Unit tests for generate_key.py functionality"""
    
    def test_key_generation_with_no_existing_env(self):
        """Test key generation when no .env file exists"""
        with tempfile.TemporaryDirectory() as tmpdir:
            env_file = os.path.join(tmpdir, '.env')
            
            # Generate a key
            key = Fernet.generate_key().decode('utf-8')
            
            # Write new .env file (simulating generate_key.py)
            with open(env_file, 'w') as f:
                f.write('# Django Settings\n')
                f.write('SECRET_KEY=your-secret-key-here\n')
                f.write('DEBUG=True\n\n')
                f.write('# RCON Encryption Key\n')
                f.write(f'RCON_ENCRYPTION_KEY={key}\n')
            
            # Verify file was created
            assert os.path.exists(env_file)
            
            # Verify key is in file
            with open(env_file, 'r') as f:
                content = f.read()
            
            assert f'RCON_ENCRYPTION_KEY={key}' in content
            assert 'SECRET_KEY=' in content
    
    def test_key_generation_with_existing_env(self):
        """Test key generation when .env file already exists"""
        with tempfile.TemporaryDirectory() as tmpdir:
            env_file = os.path.join(tmpdir, '.env')
            
            # Create existing .env
            old_key = 'old_key_value'
            with open(env_file, 'w') as f:
                f.write('SECRET_KEY=existing_secret\n')
                f.write(f'RCON_ENCRYPTION_KEY={old_key}\n')
                f.write('OTHER_SETTING=value\n')
            
            # Generate new key
            new_key = Fernet.generate_key().decode('utf-8')
            
            # Update .env file (simulating generate_key.py)
            with open(env_file, 'r') as f:
                lines = f.readlines()
            
            with open(env_file, 'w') as f:
                for line in lines:
                    if line.startswith('RCON_ENCRYPTION_KEY='):
                        f.write(f'RCON_ENCRYPTION_KEY={new_key}\n')
                    else:
                        f.write(line)
            
            # Verify key was updated
            with open(env_file, 'r') as f:
                content = f.read()
            
            assert f'RCON_ENCRYPTION_KEY={new_key}' in content
            assert old_key not in content
            assert 'SECRET_KEY=existing_secret' in content
            assert 'OTHER_SETTING=value' in content
    
    def test_backup_file_naming_format(self):
        """Test that backup files follow the correct naming format"""
        with tempfile.TemporaryDirectory() as tmpdir:
            env_file = os.path.join(tmpdir, '.env')
            
            # Create .env file
            with open(env_file, 'w') as f:
                f.write('TEST=value\n')
            
            # Create backup with timestamp
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_file = os.path.join(tmpdir, f'.env.backup_{timestamp}')
            shutil.copy2(env_file, backup_file)
            
            # Verify backup file exists and has correct format
            assert os.path.exists(backup_file)
            basename = os.path.basename(backup_file)
            assert basename.startswith('.env.backup_')
            assert len(basename) == len('.env.backup_YYYYMMDD_HHMMSS')
    
    def test_generated_key_format(self):
        """Test that generated keys have the correct format"""
        # Generate multiple keys and verify format
        for _ in range(10):
            key = Fernet.generate_key().decode('utf-8')
            
            # Should be 44 characters
            assert len(key) == 44, f"Key should be 44 characters, got {len(key)}"
            
            # Should be valid base64
            is_valid, _ = KeyValidator.validate_key(key)
            assert is_valid, "Generated key should be valid"
            
            # Should work with EncryptionUtility
            util = EncryptionUtility(key=key)
            assert util.verify_encryption("test"), "Key should work for encryption"
